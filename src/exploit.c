#include "exploit.h"

static void display_header_data(Elf64_Ehdr *e_h, Elf64_Phdr *p_h)
{
    printf("Elf Header Entries:\n");
    printf("Entry_p\tPH_Offset\t\n");
    printf("%08lx\t%lx\n", e_h->e_entry, e_h->e_phoff);
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; i < e_h->e_phnum; i++)
    {
        printf("%x\t%08lx\t%016lx\t%016lx\t%08lx\t%08lx\t%x\t%lx\n",
               p_h[i].p_type, p_h[i].p_offset, p_h[i].p_vaddr,
               p_h[i].p_paddr, p_h[i].p_filesz, p_h[i].p_memsz,
               p_h[i].p_flags, p_h[i].p_align);
    }
}

static void *fill_buffer(const STORED_FILE *sf, const ELF64_FORMAT *elf, int32_t idx)
{
    void *buf;
    buf = malloc(sf->size);
    memcpy(buf, sf->ptr, (size_t)(elf->p_h[idx].p_offset + elf->p_h[idx].p_filesz));
    return buf;
}

static void increase_segments_offset(Elf64_Ehdr *e_h, Elf64_Phdr *p_h, int32_t sgmt, int page_size)
{
    for (sgmt += 1; sgmt < e_h->e_phnum; sgmt++)
    {
        printf("LOOP\n");
        (p_h[sgmt]).p_offset += page_size;
    }
}

EXPLOIT_INFO *get_exploit_info(const STORED_FILE *sf, const ELF64_FORMAT *elf)
{
    EXPLOIT_INFO *tmp;

    tmp = malloc(sizeof(EXPLOIT_INFO));
    tmp->page_size = sysconf(_SC_PAGE_SIZE);
    if (tmp->text_section_idx = get_text_section(sf, elf) < 0)
        goto _find_load_segment;
    tmp->exploit_segment_idx = find_text_segment(sf, elf, tmp->text_section_idx);

_find_load_segment:
    printf("find PT_LOAD brooo ");
}

ELF64_FORMAT *extract_headers_from_sf(const STORED_FILE *sf, int bin_arch)
{
    ELF64_FORMAT *elf;
    if (bin_arch == x64)
    {
        elf = malloc(sizeof(ELF64_FORMAT));
        elf->e_h = (Elf64_Ehdr *)sf->ptr;
        elf->s_h = (Elf64_Shdr *)(sf->ptr + elf->e_h->e_shoff);
        elf->p_h = (Elf64_Phdr *)(sf->ptr + elf->e_h->e_phoff);
        return elf;
    }
    else
    {
        ELF32_FORMAT *tmp;
        tmp = malloc(sizeof(ELF32_FORMAT));
        tmp->e_h = (Elf32_Ehdr *)sf->ptr;
        tmp->s_h = (Elf32_Shdr *)(sf->ptr + tmp->e_h->e_shoff);
        tmp->p_h = (Elf32_Phdr *)(sf->ptr + tmp->e_h->e_phoff);
        elf = convert32_64(tmp);
        printf("Entry_p\tPH_Offset\t\n");
        printf("%08x\t%x\n", tmp->e_h->e_entry, tmp->e_h->e_phoff);
        printf("Program Header Entries:\n");
        printf("==================================\n");
        printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

        for (int i = 0; i < tmp->e_h->e_phnum; i++)
        {
            printf("%x\t%08x\t%016x\t%016x\t%08x\t%08x\t%x\t%x\n",
                   tmp->p_h[i].p_type, tmp->p_h[i].p_offset, tmp->p_h[i].p_vaddr,
                   tmp->p_h[i].p_paddr, tmp->p_h[i].p_filesz, tmp->p_h[i].p_memsz,
                   tmp->p_h[i].p_flags, tmp->p_h[i].p_align);
        }
    }

    printf("64\n==========\nElf Header Entries:\n");
    printf("Entry_p\tPH_Offset\t\n");
    printf("%08lx\t%lx\n", elf->e_h->e_entry, elf->e_h->e_phoff);
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; i < elf->e_h->e_phnum; i++)
    {
        printf("%x\t%08lx\t%016lx\t%016lx\t%08lx\t%08lx\t%x\t%lx\n",
               elf->p_h[i].p_type, elf->p_h[i].p_offset, elf->p_h[i].p_vaddr,
               elf->p_h[i].p_paddr, elf->p_h[i].p_filesz, elf->p_h[i].p_memsz,
               elf->p_h[i].p_flags, elf->p_h[i].p_align);
    }
    return elf;
}

void elf_exploit(const STORED_FILE *sf, int bin_arch)
{
    // test(sf);
    EXPLOIT_INFO *info;
    ELF64_FORMAT *elf;
    void *buf;
    elf = extract_headers_from_sf(sf, bin_arch);
}
/*   if (bin_arch == x64)
    {
        printf("64 creation");
        elf->e_h = (Elf64_Ehdr *)sf->ptr;
        elf->s_h = (Elf64_Shdr *)(sf->ptr + ((Elf64_Ehdr *)(elf->e_h))->e_shoff);
        elf->p_h = (Elf64_Phdr *)(sf->ptr + ((Elf64_Ehdr *)(elf->e_h))->e_phoff);
    }
    else
    {
        printf("32 creation");
        elf->e_h = (Elf32_Ehdr *)sf->ptr;
        elf->s_h = (Elf32_Shdr *)(sf->ptr + ((Elf32_Ehdr *)(elf->e_h))->e_shoff);
        elf->p_h = (Elf32_Phdr *)(sf->ptr + ((Elf32_Ehdr *)(elf->e_h))->e_phoff);
    }
    printf("32 size = %d\n", ((Elf32_Ehdr *)elf->e_h)->e_ehsize);
    * /
        // info = get_exploit_info(sf, elf);
    /*buf = fill_buffer(sf, elf, segment);
    Elf64_Ehdr *e_h;
    Elf64_Phdr *p_h;
    e_h = (Elf64_Ehdr *)buf;
    p_h = (Elf64_Phdr *)(buf + e_h->e_phoff);
    display_header_data(e_h, p_h);
    // Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
    // index_memcpy(buf, payload, (p_h[segment].p_offset + p_h[segment].p_filesz)); // memcpy with a startIndex for the src and the dist
    // ! // TODO fill the PAGE_SIZE - payload with 00
    // Increase file and mem sz by the size of the payload
    p_h[segment].p_filesz += payload_size;
    p_h[segment].p_memsz += payload_size;

    // Increase each segment offset after the parasite segment by the PAGE_SIZE
    increase_segments_offset(e_h, p_h, segment, page_size);
    display_header_data(e_h, p_h);
    // Find the last section of the infected segment and increase the size by the length of the parasite
    // Increase each section offset after the parasite section by PAGE_SIZE
    free(buf);
    free(elf);

    return;

    // find_pt_load();
}*/