#include "exploit.h"
// TODO put STATIC functions
// TODO faire la version ou le section header a ete delete

#define TT_ 11
/*
static void display_e_h(Elf64_Ehdr *e_h)
{
}
static void display_p_h(Elf64_Phdr *p_h)
{
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; p_h[i] != NULL; i++)
    {
        printf("%08x\t%08x\t%016x\t%016x\t%08x\t%08x\t%x\t%x\n",
               p_h[i].p_type, p_h[i].p_offset, p_h[i].p_vaddr,
               p_h[i].p_paddr, p_h[i].p_filesz, p_h[i].p_memsz,
               p_h[i].p_flags, p_h[i].p_align);
    }
}
static void display_s_h(Elf64_Shdr *s_h)
{
}

static void display_data(size_t info_to_display, ...)
{
    va_list parametersInfos;
va_start(parametersInfos, info_to_display);

size_t writtenCharacters = 0;
char currentChar;

if ((E_H & info_to_display) == E_H)
{
    Elf64_Ehdr e_h = (Elf64_Ehdr)va_arg(parametersInfos, Elf64_Ehdr);
    display_e_h(e_h);
}
if ((P_H & info_to_display) == P_H)
{
    Elf64_Phdr p_h = (Elf64_Phdr)va_arg(parametersInfos, Elf64_Phdr);
    display_p_h(p_h);
}
if ((S_H & info_to_display) == S_H)
{
    Elf64_Shdr s_h = (Elf64_Shdr)va_arg(parametersInfos, Elf64_Shdr);
    display_s_h(s_h);
}
va_end(parametersInfos);
}
*/
void display_header_data32(const Elf32_Ehdr *e_h, const Elf32_Phdr *p_h, const Elf32_Shdr *s_h)
{
    printf("Elf Header Entries:\n");
    printf("Type\tMachine\tVersion\tEntry\tPhoff\tShoff\tFlags\tEhSize\tPhEntSize\tPhNum\tShEntSize\tShNum\tShStrndx\n");
    printf("%08x\t%016x\t%016x\t%016x\t%016x\t%08x\t%08x\t%08x\t%08x\t\t\t%08x\t%08x\t%08x\t%08x\n",
           e_h->e_type,
           e_h->e_machine,
           e_h->e_version,
           e_h->e_entry,
           e_h->e_phoff,
           e_h->e_shoff,
           e_h->e_flags,
           e_h->e_ehsize,
           e_h->e_phentsize,
           e_h->e_phnum,
           e_h->e_shentsize,
           e_h->e_shnum,
           e_h->e_shstrndx);
    printf("Entry_p\tPH_Offset\t\n");
    printf("%08x\t%x\n", e_h->e_entry, e_h->e_phoff);
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; i < e_h->e_phnum; i++)
    {
        printf("%08x\t%08x\t%016x\t%016x\t%08x\t%08x\t%x\t%x\n",
               p_h[i].p_type, p_h[i].p_offset, p_h[i].p_vaddr,
               p_h[i].p_paddr, p_h[i].p_filesz, p_h[i].p_memsz,
               p_h[i].p_flags, p_h[i].p_align);
    }
    printf("Section Header Entries:\n");
    printf("==================================\n");
    printf("Type\t\tAddress\t\t\tOffset\t\t\tSize\t\t\tEntSize\t\t\tFlags\t\tLink\t\tInfo\t\tAlign\n");

    for (int i = 0; i < e_h->e_shnum; i++)
    {
        printf("%08x\t%016x\t%016x\t%016x\t%016x\t%08x\t%08x\t%08x\t%016x\n",
               s_h[i].sh_type,
               s_h[i].sh_addr,
               s_h[i].sh_offset,
               s_h[i].sh_size,
               s_h[i].sh_entsize,
               s_h[i].sh_flags,
               s_h[i].sh_link,
               s_h[i].sh_info,
               s_h[i].sh_addralign);
    }
}
void display_header_data(const Elf64_Ehdr *e_h, const Elf64_Phdr *p_h, const Elf64_Shdr *s_h)
{
    printf("Elf Header Entries:\n");
    printf("Entry_p\tPH_Offset\t\n");
    printf("%08lx\t%lx\n", e_h->e_entry, e_h->e_phoff);
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; i < e_h->e_phnum; i++)
    {
        printf("%08x\t%08lx\t%016lx\t%016lx\t%08lx\t%08lx\t%x\t%lx\n",
               p_h[i].p_type, p_h[i].p_offset, p_h[i].p_vaddr,
               p_h[i].p_paddr, p_h[i].p_filesz, p_h[i].p_memsz,
               p_h[i].p_flags, p_h[i].p_align);
    }
    printf("Section Header Entries:\n");
    printf("==================================\n");
    printf("Type\t\tAddress\t\t\tOffset\t\t\tSize\t\t\tEntSize\t\t\tFlags\t\tLink\t\tInfo\t\tAlign\n");

    for (int i = 0; i < e_h->e_shnum; i++)
    {
        printf("%08x\t%016lx\t%016lx\t%016lx\t%016lx\t%08lx\t%08x\t%08x\t%016lx\n",
               s_h[i].sh_type,
               s_h[i].sh_addr,
               s_h[i].sh_offset,
               s_h[i].sh_size,
               s_h[i].sh_entsize,
               s_h[i].sh_flags,
               s_h[i].sh_link,
               s_h[i].sh_info,
               s_h[i].sh_addralign);
    }
}

void *begin_buffer(const STORED_FILE *sf, const ELF64_FORMAT *elf, EXPLOIT_INFO *info, int32_t idx)
{
    void *buf;
    buf = calloc(1, sf->size + info->page_size);
    memcpy(buf, sf->ptr, (size_t)(elf->p_h[idx].p_offset + elf->p_h[idx].p_filesz));
    return buf;
}
/**
 * @brief fill the end (after the injection of the payload) of the infected buffer after determinating
 * the alignement is correct, if not add page_size in between the infected segment and the next one
 */
void *end_buffer(const STORED_FILE *sf, void *buf, const ELF64_FORMAT *elf, EXPLOIT_INFO *info)
{
    size_t memcpy_len;
    size_t dest_offset;
    size_t src_offset;
    if (info->e_p_idx != (elf->e_h->e_phnum - 1))
    {
        memcpy_len = sf->size - ((elf->p_h[(info->e_p_idx) + 1].p_offset));
        dest_offset = (elf->p_h[(info->e_p_idx) + 1].p_offset + info->page_size);
        src_offset = (elf->p_h[(info->e_p_idx) + 1].p_offset);
        printf("dest offset = %zx\n", memcpy_len);
        printf("dest offset = %zx\n", dest_offset);
        printf("src offset = %zx\n", src_offset);
    }
    else
    {
        memcpy_len = sf->size - elf->e_h->e_shoff;
        dest_offset = (elf->p_h[info->e_p_idx + 1].p_offset + info->page_size);
        src_offset = (elf->p_h[info->e_p_idx + 1].p_offset);
    }
    memcpy_len = sf->size - (info->explt_p->p_offset + info->explt_p->p_filesz);
    dest_offset = ((info->explt_p->p_offset + info->explt_p->p_filesz) + info->page_size);
    src_offset = (info->explt_p->p_offset + info->explt_p->p_filesz);
    memcpy(buf + dest_offset, sf->ptr + src_offset, memcpy_len);
    return buf;
}
/**
 * @brief change the value of the differents headers to match the current value of the buffer
 */
/*void *fi(void *buf, const ELF64_FORMAT *elf, EXPLOIT_INFO *info)
{

    return buf;
}*/

static void increase_segments_offset(ELF64_FORMAT *elf, int32_t idx, int size)
{
    for (idx += 1; idx < elf->e_h->e_phnum; idx++)
        (elf->p_h[idx]).p_offset += size;
}

static void increase_sections_offset(ELF64_FORMAT *elf, int32_t idx, int size)
{
    for (idx += 1; idx < elf->e_h->e_shnum; idx++)
        (elf->s_h[idx]).sh_offset += size;
}

// ! // TODO check return value if section or segment not found
EXPLOIT_INFO *get_exploit_info(const STORED_FILE *sf, const ELF64_FORMAT *elf)
{
    EXPLOIT_INFO *tmp;

    tmp = malloc(sizeof(EXPLOIT_INFO));
    tmp->page_size = sysconf(_SC_PAGE_SIZE);
    if ((tmp->text_s_idx = get_text_section(sf, elf)) < 0)
        goto _find_load_segment;
    tmp->e_p_idx = find_text_segment(elf, tmp->text_s_idx);
    tmp->e_s_idx = find_section_endof_segment(elf, tmp->e_p_idx);
    // TODO change the way i get the value

    tmp->text_s = &(elf->s_h[tmp->text_s_idx]);
    tmp->explt_s = &(elf->s_h[tmp->e_s_idx]);
    tmp->explt_p = &(elf->p_h[tmp->e_p_idx]);
    tmp->old_entry = &(elf->e_h->e_entry);
    tmp->bin_arch = elf->e_h->e_ident[EI_CLASS];
    return tmp;
_find_load_segment:
    printf("find PT_LOAD brooo ");
    return tmp;
}

ELF64_FORMAT *extract_headers_from_sf(const STORED_FILE *sf)
{
    char *bin_arch = sf->ptr + 4;
    printf("%d\n", *bin_arch);
    ELF64_FORMAT *elf;
    if (*bin_arch == x64)
    {
        elf = malloc(sizeof(ELF64_FORMAT));
        elf->e_h = malloc(sizeof(Elf64_Ehdr));
        memcpy(elf->e_h, sf->ptr, sizeof(Elf64_Ehdr));
        elf->p_h = malloc(sizeof(Elf64_Phdr) * elf->e_h->e_phnum);
        elf->s_h = malloc(sizeof(Elf64_Shdr) * elf->e_h->e_shnum);
        memcpy(elf->s_h, (sf->ptr + elf->e_h->e_shoff), sizeof(Elf64_Shdr) * elf->e_h->e_shnum);
        memcpy(elf->p_h, (sf->ptr + elf->e_h->e_phoff), sizeof(Elf64_Phdr) * elf->e_h->e_phnum);
    }
    else
    {
        ELF32_FORMAT *tmp;
        tmp = malloc(sizeof(ELF32_FORMAT));
        tmp->e_h = (Elf32_Ehdr *)sf->ptr;
        tmp->s_h = (Elf32_Shdr *)(sf->ptr + tmp->e_h->e_shoff);
        tmp->p_h = (Elf32_Phdr *)(sf->ptr + tmp->e_h->e_phoff);
        elf = convert32_64(tmp);
    }
    return elf;
}

void elf_exploit(const STORED_FILE *sf)
{
    EXPLOIT_INFO *info;
    ELF64_FORMAT *elf;
    void *buf;

    elf = extract_headers_from_sf(sf);
    info = get_exploit_info(sf, elf);

    buf = begin_buffer(sf, elf, info, info->e_p_idx);

    info->key_ptr = malloc(KEY_LENGTH);
    keygen(KEY_LENGTH, info->key_ptr);
    encrypt(buf + (info->text_s->sh_offset), info->text_s->sh_size, info->key_ptr, KEY_LENGTH / 8, buf + (info->text_s->sh_offset));

    //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
    info->payload = get_unpacker((void *)elf->e_h->e_entry, info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
    printf("entry = %lx\n", elf->e_h->e_entry);
    // TODO possible problem here, need to align
    memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz) + TT_, info->payload, UNPACKER_SIZE_64);

    end_buffer(sf, buf, elf, info);
    // char *hex = (char *)buf;
    /*printf("%d\n", info->text_s_idx);
    printf("%lu\n", info->text_s->sh_offset);
    for (Elf64_Off i = 0; i < sf->size + info->page_size (elf->p_h[(info->e_p_idx) + 1].p_offset)
    ; i++)
    {
        printf("%02x", (hex[i] & 0xff));
        if (i % 2 == 1)
            printf(" ");
        if ((i + 1) % 16 == 0 && i != 0)
            printf("\n%07lx ", i + 1);
    }
    */
    //  ! // TODO fill the PAGE_SIZE - payload with 00

    // Increase each segment offset after the parasite segment by the PAGE_SIZE
    increase_segments_offset(elf, info->e_p_idx, info->page_size);

    // Find the last section of the infected segment and increase the size by the length of the parasite
    info->explt_s->sh_size += (info->bin_arch == x64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    info->explt_p->p_flags |= PF_W;

    // Change the entrypoint of elf header and the offset of the sh_offset
    elf->e_h->e_entry = info->explt_p->p_paddr + info->explt_p->p_filesz + TT_;

    //  Increase file and mem sz by the size of the payload
    info->explt_p->p_memsz += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    info->explt_p->p_filesz += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;

    printf("entry =%lx\n\n", elf->e_h->e_entry);
    elf->e_h->e_shoff += info->page_size;
    printf("pvaddr =%lx\n\n", info->explt_p->p_paddr);
    printf("pfsize =%lx\n\n", info->explt_p->p_filesz);
    printf("elf->e_entry = %lu\n\n", elf->e_h->e_entry);
    // Increase each section offset after the parasite section by PAGE_SIZE
    increase_sections_offset(elf, info->e_s_idx, info->page_size);

    if (info->bin_arch == ELFCLASS64)
    {
        memcpy(buf, elf->e_h, sizeof(Elf64_Ehdr));
        memcpy(buf + elf->e_h->e_phoff, elf->p_h, sizeof(Elf64_Phdr) * elf->e_h->e_phnum);
        memcpy(buf + elf->e_h->e_shoff, elf->s_h, sizeof(Elf64_Shdr) * elf->e_h->e_shnum);
    }
    else
    {
        ELF32_FORMAT *elf32;
        elf32 = convert64_32(elf);
        memcpy(buf, elf32->e_h, sizeof(Elf32_Ehdr));
        memcpy(buf + elf32->e_h->e_phoff, elf32->p_h, sizeof(Elf32_Phdr) * elf32->e_h->e_phnum);
        memcpy(buf + elf32->e_h->e_shoff, elf32->s_h, sizeof(Elf32_Shdr) * elf32->e_h->e_shnum);
    }

    FILE *virus = fopen("wood", "wb");
    if (virus == NULL)
    {
        printf("trouble opening the virus file\n");
    }
    fwrite(buf, 1, sf->size + info->page_size, virus);
    fclose(virus);
}