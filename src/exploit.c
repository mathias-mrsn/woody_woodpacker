#include "exploit.h"
#include <elf.h>

void display_header_data32(const Elf32_Ehdr *e_h, const Elf32_Phdr *p_h, const Elf32_Shdr *s_h)
{
    printf("Elf Header Entries:\n");
    printf("Type\tMachine\tVersion\tEntry\tPhoff\tShoff\tFlags\tEhSize\tPhEntSize\tPhNum\tShEntSize\tShNum\tShStrndx\n");
    printf("%08x\t%016x\t%016x\t%016x\t%016x\t%08x\t%08x\t%08x\t%08x\t\t\t%08x\t%08x\t%08x\t%08x\n",
           e_h->e_type,
           e_h->e_machine,
           e_h->e_version,
           e_h->e_entry,
           e_h->e_phoff,
           e_h->e_shoff,
           e_h->e_flags,
           e_h->e_ehsize,
           e_h->e_phentsize,
           e_h->e_phnum,
           e_h->e_shentsize,
           e_h->e_shnum,
           e_h->e_shstrndx);
    printf("Entry_p\tPH_Offset\t\n");
    printf("%08x\t%x\n", e_h->e_entry, e_h->e_phoff);
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; i < e_h->e_phnum; i++)
    {
        printf("%08x\t%08x\t%016x\t%016x\t%08x\t%08x\t%x\t%x\n",
               p_h[i].p_type, p_h[i].p_offset, p_h[i].p_vaddr,
               p_h[i].p_paddr, p_h[i].p_filesz, p_h[i].p_memsz,
               p_h[i].p_flags, p_h[i].p_align);
    }
    printf("Section Header Entries:\n");
    printf("==================================\n");
    printf("Type\t\tAddress\t\t\tOffset\t\t\tSize\t\t\tEntSize\t\t\tFlags\t\tLink\t\tInfo\t\tAlign\n");

    for (int i = 0; i < e_h->e_shnum; i++)
    {
        printf("%08x\t%016x\t%016x\t%016x\t%016x\t%08x\t%08x\t%08x\t%016x\n",
               s_h[i].sh_type,
               s_h[i].sh_addr,
               s_h[i].sh_offset,
               s_h[i].sh_size,
               s_h[i].sh_entsize,
               s_h[i].sh_flags,
               s_h[i].sh_link,
               s_h[i].sh_info,
               s_h[i].sh_addralign);
    }
}
void display_header_data(const Elf64_Ehdr *e_h, const Elf64_Phdr *p_h, const Elf64_Shdr *s_h)
{
    printf("Elf Header Entries:\n");
    printf("Entry_p\tPH_Offset\t\n");
    printf("%08lx\t%lx\n", e_h->e_entry, e_h->e_phoff);
    printf("Program Header Entries:\n");
    printf("==================================\n");
    printf("Type\tOffset\t\tVirtAddr\tPhysAddr\tFileSiz\tMemSiz\tFlags\tAlign\n");

    for (int i = 0; i < e_h->e_phnum; i++)
    {
        printf("%08x\t%08lx\t%016lx\t%016lx\t%08lx\t%08lx\t%x\t%lx\n",
               p_h[i].p_type, p_h[i].p_offset, p_h[i].p_vaddr,
               p_h[i].p_paddr, p_h[i].p_filesz, p_h[i].p_memsz,
               p_h[i].p_flags, p_h[i].p_align);
    }
    printf("Section Header Entries:\n");
    printf("==================================\n");
    printf("Type\t\tAddress\t\t\tOffset\t\t\tSize\t\t\tEntSize\t\t\tFlags\t\tLink\t\tInfo\t\tAlign\n");

    for (int i = 0; i < e_h->e_shnum; i++)
    {
        printf("%08x\t%016lx\t%016lx\t%016lx\t%016lx\t%08lx\t%08x\t%08x\t%016lx\n",
               s_h[i].sh_type,
               s_h[i].sh_addr,
               s_h[i].sh_offset,
               s_h[i].sh_size,
               s_h[i].sh_entsize,
               s_h[i].sh_flags,
               s_h[i].sh_link,
               s_h[i].sh_info,
               s_h[i].sh_addralign);
    }
}

void *begin_buffer(void **buf, const STORED_FILE *sf, const ELF64_FORMAT *elf, EXPLOIT_INFO *info, int32_t idx)
{
    if (!(*buf = calloc(1, sf->size + info->page_size)))
        return NULL;
    memcpy(*buf, sf->ptr, (size_t)(elf->p_h[idx].p_offset + elf->p_h[idx].p_filesz));
    return *buf;
}
/**
 * @brief fill the end (after the injection of the payload) of the infected buffer after determinating
 * the alignement is correct, if not add page_size in between the infected segment and the next one
 */
void *end_buffer(const STORED_FILE *sf, void *buf, const ELF64_FORMAT *elf, EXPLOIT_INFO *info)
{
    size_t memcpy_len;
    size_t dest_offset;
    size_t src_offset;

    memcpy_len = sf->size - (info->explt_p->p_offset + info->explt_p->p_filesz);
    dest_offset = ((info->explt_p->p_offset + info->explt_p->p_filesz) + info->page_size);
    src_offset = (info->explt_p->p_offset + info->explt_p->p_filesz);
    memcpy(buf + dest_offset, sf->ptr + src_offset, memcpy_len);
    return buf;
}

static void increase_segments_offset(ELF64_FORMAT *elf, int32_t idx, int size)
{
    for (idx += 1; idx < elf->e_h->e_phnum; idx++)
    {
        // if (elf->p_h[idx].p_type == PT_NOTE)
        //     break;
        (elf->p_h[idx]).p_offset += size;
        // (elf->p_h[idx]).p_vaddr += size;
        // (elf->p_h[idx]).p_paddr += size;
    }
}

static void increase_sections_offset(ELF64_FORMAT *elf, int32_t idx, int size)
{
    for (idx += 1; idx < elf->e_h->e_shnum; idx++)
    {
        (elf->s_h[idx]).sh_offset += size;
        (elf->s_h[idx]).sh_addr += size;
    }
}

bool sh_less(EXPLOIT_INFO *info)
{
    return info->sh_less;
}

int exploit(const STORED_FILE *sf)
{
    EXPLOIT_INFO *info;
    ELF64_FORMAT *elf;
    ELF32_FORMAT *elf32;
    void *buf;

    info = NULL;
    elf32 = NULL;
    elf = NULL;
    buf = NULL;

    if (!(extract_headers_from_sf(sf, &elf)))
        return free_exploit(elf, info, buf, elf32);

    if (!(get_exploit_info(sf, elf, &info)))
        return free_exploit(elf, info, buf, elf32);

    if (code_cave_available(info, elf))
        codecave_exploit(sf, info, elf);
    else
        note_exploit(sf, info, elf);
    // if (!(begin_buffer(&buf, sf, elf, info, info->e_p_idx)))
    //     return free_exploit(elf, info, buf, elf32);

    // if (sh_less(info))
    // {
    //     encrypt(buf + (info->explt_p->p_offset), info->explt_p->p_filesz, info->key_ptr, KEY_LENGTH / 8, buf + (info->explt_p->p_offset));

    //     //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
    //     if (info->bin_arch == ELFCLASS64)
    //     {
    //         info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->explt_p->p_vaddr, KEY_LENGTH / 8, info->explt_p->p_filesz, info->bin_arch == ELFCLASS64);
    //         memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_64);
    //     }
    //     else
    //     {
    //         info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->explt_p->p_vaddr, KEY_LENGTH / 8, info->explt_p->p_filesz, info->bin_arch == ELFCLASS64);
    //         memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_32);
    //     }
    // }
    // else
    // {
    //     encrypt(buf + (info->text_s->sh_offset), info->text_s->sh_size, info->key_ptr, KEY_LENGTH / 8, buf + (info->text_s->sh_offset));

    //     printf("%lx\n", (info->explt_p->p_vaddr + info->explt_p->p_filesz));
    //     printf("%lx\n", (elf->e_h->e_entry));
    //     //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
    //     if (info->bin_arch == ELFCLASS64)
    //     {
    //         info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
    //         memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_64);
    //     }
    //     else
    //     {
    //         info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
    //         memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_32);
    //     }
    // }
    // end_buffer(sf, buf, elf, info);
    // // Increase each segment offset after the parasite segment by the PAGE_SIZE
    // increase_segments_offset(elf, info->e_p_idx, info->page_size);

    // info->explt_p->p_flags |= PF_W;

    // // Change the entrypoint of elf header and the offset of the sh_offset
    // elf->e_h->e_entry = info->explt_p->p_paddr + info->explt_p->p_filesz;

    // //  Increase file and mem sz by the size of the payload
    // info->explt_p->p_memsz += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    // info->explt_p->p_filesz += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;

    // elf->e_h->e_shoff += info->page_size;

    // if (!(sh_less(info)))
    // {
    //     // Increase each section offset after the parasite section by PAGE_SIZE
    //     increase_sections_offset(elf, info->e_s_idx, info->page_size);
    //     // Find the last section of the infected segment and increase the size by the length of the parasite
    //     info->explt_s->sh_size += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    // }

    // if (info->bin_arch == ELFCLASS64)
    // {
    //     memcpy(buf, elf->e_h, sizeof(Elf64_Ehdr));
    //     memcpy(buf + elf->e_h->e_phoff, elf->p_h, sizeof(Elf64_Phdr) * elf->e_h->e_phnum);
    //     if (!sh_less(info))
    //         memcpy(buf + elf->e_h->e_shoff, elf->s_h, sizeof(Elf64_Shdr) * elf->e_h->e_shnum);
    // }
    // else
    // {
    //     if (!(elf32 = convert64_32(elf, sf)))
    //         return free_exploit(elf, info, buf, elf32);
    //     memcpy(buf, elf32->e_h, sizeof(Elf32_Ehdr));
    //     memcpy(buf + elf32->e_h->e_phoff, elf32->p_h, sizeof(Elf32_Phdr) * elf32->e_h->e_phnum);
    //     if (!sh_less(info))
    //         memcpy(buf + elf32->e_h->e_shoff, elf32->s_h, sizeof(Elf32_Shdr) * elf32->e_h->e_shnum);
    // }

    // virus = open("woody", O_RDWR | O_CREAT | O_TRUNC, 0777);
    // if (virus < 0)
    //     goto _exit;
    // write(virus, buf, sf->size + info->page_size);

_exit:
    return EXIT_SUCCESS;
}

int codecave_exploit(const STORED_FILE *sf, EXPLOIT_INFO *info, ELF64_FORMAT *elf)
{
    int virus;
    ELF32_FORMAT *elf32;
    void *buf;

    elf32 = NULL;
    buf = NULL;

    if (!(begin_buffer(&buf, sf, elf, info, info->e_p_idx)))
        return free_exploit(elf, info, buf, elf32);

    if (sh_less(info))
    {
        encrypt(buf + (info->explt_p->p_offset), info->explt_p->p_filesz, info->key_ptr, KEY_LENGTH / 8, buf + (info->explt_p->p_offset));

        //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
        if (info->bin_arch == ELFCLASS64)
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->explt_p->p_vaddr, KEY_LENGTH / 8, info->explt_p->p_filesz, info->bin_arch == ELFCLASS64);
            memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_64);
        }
        else
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->explt_p->p_vaddr, KEY_LENGTH / 8, info->explt_p->p_filesz, info->bin_arch == ELFCLASS64);
            memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_32);
        }
    }
    else
    {
        encrypt(buf + (info->text_s->sh_offset), info->text_s->sh_size, info->key_ptr, KEY_LENGTH / 8, buf + (info->text_s->sh_offset));

        //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
        if (info->bin_arch == ELFCLASS64)
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
            memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_64);
        }
        else
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(info->explt_p->p_vaddr + info->explt_p->p_filesz)), info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
            memcpy(buf + (info->explt_p->p_offset + info->explt_p->p_filesz), info->payload, UNPACKER_SIZE_32);
        }
    }
    end_buffer(sf, buf, elf, info);
    // Increase each segment offset after the parasite segment by the PAGE_SIZE
    increase_segments_offset(elf, info->e_p_idx, info->page_size);

    info->explt_p->p_flags |= PF_W;

    // Change the entrypoint of elf header and the offset of the sh_offset
    elf->e_h->e_entry = info->explt_p->p_paddr + info->explt_p->p_filesz;

    //  Increase file and mem sz by the size of the payload
    info->explt_p->p_memsz += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    info->explt_p->p_filesz += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;

    elf->e_h->e_shoff += info->page_size;

    if (!(sh_less(info)))
    {
        // Increase each section offset after the parasite section by PAGE_SIZE
        increase_sections_offset(elf, info->e_s_idx, info->page_size);
        // Find the last section of the infected segment and increase the size by the length of the parasite
        info->explt_s->sh_size += (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    }

    if (info->bin_arch == ELFCLASS64)
    {
        memcpy(buf, elf->e_h, sizeof(Elf64_Ehdr));
        memcpy(buf + elf->e_h->e_phoff, elf->p_h, sizeof(Elf64_Phdr) * elf->e_h->e_phnum);
        if (!sh_less(info))
            memcpy(buf + elf->e_h->e_shoff, elf->s_h, sizeof(Elf64_Shdr) * elf->e_h->e_shnum);
    }
    else
    {
        if (!(elf32 = convert64_32(elf, sf)))
            return free_exploit(elf, info, buf, elf32);
        memcpy(buf, elf32->e_h, sizeof(Elf32_Ehdr));
        memcpy(buf + elf32->e_h->e_phoff, elf32->p_h, sizeof(Elf32_Phdr) * elf32->e_h->e_phnum);
        if (!sh_less(info))
            memcpy(buf + elf32->e_h->e_shoff, elf32->s_h, sizeof(Elf32_Shdr) * elf32->e_h->e_shnum);
    }

    virus = open("woody", O_RDWR | O_CREAT | O_TRUNC, 0777);
    if (virus < 0)
        goto _exit;
    write(virus, buf, sf->size + info->page_size);

_exit:
    close(virus);
    free_exploit(elf, info, buf, elf32);
    return EXIT_SUCCESS;
}