#ifndef EXPLOIT_H
#define EXPLOIT_H

#include <stdlib.h>
#include <elf.h>
#include "stored_file.h"
#include "asm.h"
#include "unpacker.h"

//! // TODO possibly deletable
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define E_H (1 << 0)
#define P_H (1 << 1)
#define S_H (1 << 2)

enum
{
    NOTE_LOAD = 1,
    CODE_CAVE
};

typedef struct sELF64_FORMAT
{
    /**
     * elf header
     */
    Elf64_Ehdr *e_h;
    /**
     * program header / segment header
     */
    Elf64_Phdr *p_h;
    /**
     * section header
     */
    Elf64_Shdr *s_h;

} ELF64_FORMAT;

typedef struct sELF32_FORMAT
{
    /**
     * elf header
     */
    Elf32_Ehdr *e_h;
    /**
     * program header / segment header
     */
    Elf32_Phdr *p_h;
    /**
     * section header
     */
    Elf32_Shdr *s_h;

} ELF32_FORMAT;

typedef struct sELF_FORMAT
{
    /**
     * elf header
     */
    void *e_h;
    /**
     * program header / segment header
     */
    void *p_h;
    /**
     * section header
     */
    void *s_h;

} ELF_FORMAT;

typedef struct sEXPLOIT_INFO_NOTE
{
    // note segment index
    size_t n_p_idx;
    // maximum segment virtual address of the file
    Elf64_Addr max_addr;
    // maximum segment offset og the file
    Elf64_Off max_memsz;
    Elf64_Addr note_vaddr;

} EXPLOIT_INFO_NOTE;
typedef struct sEXPLOIT_INFO
{
    // previous entrypoint of the elf file, use to jump back on to the original program
    void *old_entry;
    // architecture of the binary file (0)=>32 (1)=>64
    int bin_arch;
    // new payload entrypoint
    void *payload_entry;
    // payload used to infect the ELF file
    void *payload;
    // length of the payload
    size_t payload_size;
    // the PAGE_SIZE value of the kernel (size in bytes of a memory page)
    size_t page_size;
    // exploited segment index
    size_t e_p_idx;
    // exploited section index
    size_t e_s_idx;
    // text section index
    int text_s_idx;
    // pointer containing the encrypt key
    void *key_ptr;

    // pointer to the exploited segment
    Elf64_Phdr *explt_p;
    // pointer to the text section
    Elf64_Shdr *text_s;
    // last section of the exploited segment
    Elf64_Shdr *explt_s;
    // indicate if the section header is strip
    bool sh_less;
    // indicate if pie is on
    bool pie;

    EXPLOIT_INFO_NOTE note;

} EXPLOIT_INFO;

/**
 * @brief return the index of the section header that represent the text section.
 *
 * @param sf the STORED_FILE structure that contain the buffer of the ELF file containing the string table
 * @param elf an structured representation of the file to access the differents strings of the table
 *
 * @return the value of the index. Return -1 if no text section find
 */
int get_text_section(const STORED_FILE *, const ELF64_FORMAT *);
int find_text_segment(const ELF64_FORMAT *, int32_t idx);
int find_executable_segment(const ELF64_FORMAT *);
int find_section_endof_segment(const ELF64_FORMAT *, int32_t idx);
void *free_elf64_struct(ELF64_FORMAT *);
void *free_elf32_struct(ELF32_FORMAT *);
void *free_exploit_info(EXPLOIT_INFO *);
int free_exploit(ELF64_FORMAT *elf, EXPLOIT_INFO *info, void *buf, ELF32_FORMAT *elf32);
ELF32_FORMAT *convert64_32(ELF64_FORMAT *, const STORED_FILE *);
ELF64_FORMAT *convert32_64(const ELF32_FORMAT *, const STORED_FILE *);
void display_header_data32(const Elf32_Ehdr *e_h, const Elf32_Phdr *p_h, const Elf32_Shdr *s_h);
EXPLOIT_INFO *get_exploit_info(const STORED_FILE *sf, const ELF64_FORMAT *elf, EXPLOIT_INFO **tmp);
ELF64_FORMAT *extract_headers_from_sf(const STORED_FILE *sf, ELF64_FORMAT **elf);
int note_exploit(const STORED_FILE *sf, EXPLOIT_INFO *info, ELF64_FORMAT *elf);
int codecave_exploit(const STORED_FILE *sf, EXPLOIT_INFO *info, ELF64_FORMAT *elf);
bool code_cave_available(EXPLOIT_INFO *info, ELF64_FORMAT *elf);

#endif