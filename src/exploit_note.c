#include "exploit.h"

void *fill_buffer_sf(void **buf, const STORED_FILE *sf, const ELF64_FORMAT *elf, EXPLOIT_INFO *info, int32_t idx)
{
    if (!(*buf = calloc(1, sf->size + UNPACKER_SIZE_64)))
        return NULL;
    memcpy(*buf, sf->ptr, (size_t)(sf->size));
    return *buf;
}

int note_exploit(const STORED_FILE *sf, EXPLOIT_INFO *info, ELF64_FORMAT *elf)
{
    // find a note segment
    // find addr max
    // find offset max + memsize
    // new offset  = max + memsize + alignement (virt - offset) % align == 0
    // new addr = max + alignement
    // write virus in it
    // change entrypoit

    // max add;
    // max offset;
    // note seg idx;
    // old entrypoint;
    int virus;
    // EXPLOIT_INFO *info;
    // ELF64_FORMAT *elf;
    ELF32_FORMAT *elf32;
    void *buf;

    // info = NULL;
    elf32 = NULL;
    // elf = NULL;
    buf = NULL;

    // if (!(extract_headers_from_sf(sf, &elf)))
    //     return free_exploit(elf, info, buf, elf32);

    // if (!(get_exploit_info(sf, elf, &info, NOTE_LOAD)))
    //     return free_exploit(elf, info, buf, elf32);
    if (info->note.n_p_idx == -1)
    {
        write(2, "Error: no injection possible\n", 30);
        goto _exit;
    }
    if (!(fill_buffer_sf(&buf, sf, elf, info, info->e_p_idx)))
        return free_exploit(elf, info, buf, elf32);

    if (sh_less(info))
    {
        encrypt(buf + (info->explt_p->p_offset), info->explt_p->p_filesz, info->key_ptr, KEY_LENGTH / 8, buf + (info->explt_p->p_offset));

        //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
        if (info->bin_arch == ELFCLASS64)
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(sf->size + info->note.note_vaddr)), info->key_ptr, (void *)info->explt_p->p_vaddr, KEY_LENGTH / 8, info->explt_p->p_filesz, info->bin_arch == ELFCLASS64);
            memcpy(buf + (sf->size), info->payload, UNPACKER_SIZE_64);
        }
        else
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(sf->size + info->note.note_vaddr)), info->key_ptr, (void *)info->explt_p->p_vaddr, KEY_LENGTH / 8, info->explt_p->p_filesz, info->bin_arch == ELFCLASS64);
            memcpy(buf + (sf->size), info->payload, UNPACKER_SIZE_32);
        }
    }
    else
    {
        encrypt(buf + (info->text_s->sh_offset), info->text_s->sh_size, info->key_ptr, KEY_LENGTH / 8, buf + (info->text_s->sh_offset));

        //  Insert the payload at the end of the text segment and add 00 to fill the PAGE_SIZE
        if (info->bin_arch == ELFCLASS64)
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(sf->size + info->note.note_vaddr)), info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
            memcpy(buf + (sf->size), info->payload, UNPACKER_SIZE_64);
        }
        else
        {
            info->payload = get_unpacker((void *)elf->e_h->e_entry, ((void *)(sf->size + info->note.note_vaddr)), info->key_ptr, (void *)info->text_s->sh_addr, KEY_LENGTH / 8, info->text_s->sh_size, info->bin_arch == ELFCLASS64);
            memcpy(buf + (sf->size), info->payload, UNPACKER_SIZE_32);
        }
    }
    info->explt_p->p_flags |= PF_W;
    elf->p_h[info->note.n_p_idx].p_type = PT_LOAD;
    elf->p_h[info->note.n_p_idx].p_flags |= PF_X;
    elf->p_h[info->note.n_p_idx].p_offset = sf->size;
    elf->p_h[info->note.n_p_idx].p_vaddr = info->note.note_vaddr + sf->size;
    elf->p_h[info->note.n_p_idx].p_paddr = info->note.note_vaddr + sf->size;
    elf->p_h[info->note.n_p_idx].p_filesz = (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    elf->p_h[info->note.n_p_idx].p_memsz = (info->bin_arch == ELFCLASS64) ? UNPACKER_SIZE_64 : UNPACKER_SIZE_32;
    elf->p_h[info->note.n_p_idx].p_align = 0x1000;

    // Change the entrypoint of elf header and the offset of the sh_offset
    elf->e_h->e_entry = info->note.note_vaddr + sf->size;
    if (info->bin_arch == ELFCLASS64)
    {
        memcpy(buf, elf->e_h, sizeof(Elf64_Ehdr));
        memcpy(buf + elf->e_h->e_phoff, elf->p_h, sizeof(Elf64_Phdr) * elf->e_h->e_phnum);
    }
    else
    {
        if (!(elf32 = convert64_32(elf, sf)))
            return free_exploit(elf, info, buf, elf32);
        memcpy(buf, elf32->e_h, sizeof(Elf32_Ehdr));
        memcpy(buf + elf32->e_h->e_phoff, elf32->p_h, sizeof(Elf32_Phdr) * elf32->e_h->e_phnum);
    }

    virus = open("woody", O_RDWR | O_CREAT | O_TRUNC, 0777);
    if (virus < 0)
        goto _close;
    write(virus, buf, sf->size + UNPACKER_SIZE_64);

_close:
    close(virus);
_exit:
    free_exploit(elf, info, buf, elf32);
    return EXIT_SUCCESS;
}